---
nav_order: 3
title: Generics - Sorted Multi Set
parent: შუალედური გამოცდის საკითხების მაგალითები
grand_parent: სავარჯიშოები
---

# SortedMultiSet

თქვენი ამოცანაა უკვე იმპლემენტირებული Vector სტრუქტურის გამოყენებით იმპლემენტაცია გაუკეთოთ SortedMultiSet მოცანემთა სტრუქტურას შემდეგი თვისებებით:

- ის ელემენტებს უნდა ინახავდეს ზრდადი მიმდევრობით.
- ელემენტებზე წვდომა შესაძლებელია ინდექსების გამოყენებით. მაგალითად თუ სიმრავლეში ჩაემატა რიცხვები შემდეგი მიმდევრობით: 5, 3 და 1 მაშინ ნულოვან ინდექსზე უნდა ინახებოდეს 1, პირველ ინდექსზე 3 ხოლო მეორე ინდექსზე 5.
- მასში შესაძლებელია ერთი და იგივე მნიშვნელობის ელემენტის რამოდენიმეჯერ ჩამატება. მაგალითად შემდეგი რიცხვების დამატების შემდეგ: 1, 5 და ისევ 1, სიმრავლის სიგრძე უნდა უყოს 2. 1 უნდა ინახებოდეს ნულოვან ინდექსზე და 5 პირველზე.
- თითოეული ელემენტისთვის შესაძლებელი უნდა იყოს გავიგოთ თუ რამდენჯერ ინახება ის სიმრავლეში. ზემოთ მოყვანილ შემთხვევაში 1 ინახება 2-ჯერ ხოლო 5 ერთხელ.

უფრო კონკრეტულად მას აქვს შემდეგი ინტერფეისი:

- void SortedMultiSetInit(SortedMultiSet\* set, int elem_size, CmpFn cmp_fn, FreeFn free_fn); -- ახდენს სიმრავლის ინიციალიზაციას. elem_size განსაზღვრავს მასში ჩამატებული ელემენტების ზომას, cmp_fn გამოყენება მასში ჩამატებული ელემენტების ერთმანეთთან შესადარებლად (აბრუნებს 0-ს თუ ელემენტები ტოლია, უარყოფით რიცხვს თუ პირველი ნაკლებია მეორეზე და დადებითს წინააღმდეგ შემთხვევაში), ხოლო არანულოვანი free_fn ფუნქციის გადაცემის შემთხვევაში ის უნდა გამოიყენოთ დამატებული ელემენტების მეხსიერების გათავისუფლებისას.
- void SortedMultiSetDestroy(SortedMultiSet\* set); -- უნდა გაანთავისუფლოს გამოყენებული მეხსიერება.
- void SortedMultiSetInsert(SortedMultiSet* set, void* elem); -- უნდა დაამატოს გადაცემული ელემენტი სიმრავლეში. თუ ელემენტი იგივე მნიშვნელობით უკვე არსებობს სიმრავლეში მაშინ უბრალოთ მისი რაოდენობის მთვლელი უნდა გაზარდოთ. იღებს მფლობელობას გადაცემულ მიმთითებელზე მყოფ ელემენტზე.
- void* SortedMultiSetGet(SortedMultiSet* set, int index); -- უნდა დააბრუნოს index ინდექსზე მდგომი ელემენტი.
- int SortedMultiSetGetCount(SortedMultiSet* set, void* elem); -- უნდა დააბრუნოს თუ რამდენჯერ გვხვდება გადაცემული ელემენტი სიმრავლეში.

**SortedMultiSet-ის იმპლემენტაციისას უნდა გამოიყენოთ მოტანილი Vector მოცანემთა სტრუქტურა. არ გაქვთ უფლება Vector-ის შიდა ცვლადებზე პირდაპირი წვდომა მოახდინოთ, უნდა გამოიყენოთ მხოლოდ მისი ინტერფეისი:**

- void VectorInit(Vector\* v, int elem_size, FreeFn free_fn); -- ახდენს ვექტორის ინიციალიზაციას.
- void VectorDestroy(Vector\* v); -- ათავისუფლებს ვექტორის მიერ გამოყენებულ მეხსიერებას და მასში შენახულ ყველა ელემენტს free_fn-ის გამოუყენებით, რათქმაუნდა თუ ის NULL არ არის.
- int VectorSize(Vector\* v); -- აბრუნებს ვექტორში შენახული ელემენტების რაოდენობას.
- void VectorInsert(Vector* v, int index, void* elem); -- index პოზიციაზე ამატებს ახალ ელემენტს. თუ indexs ვეცქტორის ზომის ტოლია მაშინ ახალი ელემენტი ვექტორის ბოლოში ემატება.
- void VectorMap(Vector* v, MapFn map_fn, void* aux); -- ვექტორის ყოველი ელემენტისთვის იძახებს გადაცემულ map_fn ფუნქციას და პირველ არგუმენტად გადასცემს ვექტორის მიმდინარე ელემენტს, ხოლო მეორე არგუმენტად VectorMap-ისთვის გადაცემულ aux არგუმენტს.

### ტესტირება

ფაილების კომპილაციისთვის გაუშვით **gcc tests.c sorted_multi_set.c vector.c**
ხოლო დაკომპილირებული ფაილის გასაშვებად: **a.exe**

## შეფასება

თითოეულ ტესტზე ინდივიდუალურად შემოწმდება თქვენი ამოხსნა სწორად იყენებს თუ არა მეხსიერებას. ყოველ წარმატებულად გავლილ ტესტზე რომლის შესრულების დროსაც თქვენი ნამუშევარი მეხსიერებას არასწორად გამოიყენებს დაგაკლდებათ ტესტისთვის განკუთვნილი ქულის 15%. სწორად გამოყენებაში იგულისხმება რომე აპლიკაცია უნდა იყენებდეს მხოლოდ მისთვის გამოყოფილ მეხსიერებას და აპლიკაციის დასრულებამდე ყველა დინამიურად გამოყოფილი მეხსერება უნდა გაათავისუფლოთ.
